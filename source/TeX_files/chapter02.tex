\chapter{Vettori e matrici}
\section{Il concetto di array}
Il vettore, chiamato più comunemente \textbf{array}, è il più semplice esempio di dato strutturato, esso consiste in una sequenza di celle consecutive ed omogenee, ovvero una sorta di contenitore di tante variabili dello stesso tipo a cui è possibile accedere tramite il nome del vettore e l’indice della variabile racchiuso tra parentesi quadre.\\
Di per se l'array nel linguaggio C non è effettivamente un tipo di dato, esso è un costruttore di tipo che permette di creare il tipo di dato appena descritto. \\
Un array si crea ponendo l'identificatore del tipo di elemnti che conterrà, il nome dell'array e la dimensione dello stesso tra parentesi quadre nel modo seguente:
\begin{lstlisting}[title={Implementazione di un array}]
//esempio con array con 3 interi
int vettore[3];

//esempio con array di 6 caratteri
char vettore_di_caratteri[6];

//esempio con array di 3 array di 2 interi
int vett[3][2];		//matrice 3*2
\end{lstlisting}
Si può usare come indice qualsiasi dato di tipo int e char.
Si possono creare array contenenti qualsiasi tipo di dato, sia esso \textit{built-in} o \textit{user-defined}, semplice o strutturato, come si è appena visto nell'esempio si possono creare anche array di array (detti comunemente array bidimensionali o matrici) e non c'è limte al numero di dimensioni che si possono sfruttare. \\
\section{Caratteristiche tecniche}
Gli elementi singoli di un array vengono trattati dal C come vere e proprie variabili (del tipo definito nella dichiarazione dell'array) e come queste possono essere coinvolte in tutte le operazioni riguardanti il loro tipo. L'array invece non può essere coinvolto globalmente in operazioni nè di assegnamento nè di confronto. Il metodo più comune per agire sull'array intero spesso prevede l'utilizzo di cicli for in cui l'iteratore fa anche da indice dell'array, come nell'esempio riportato qui sotto.
\begin{lstlisting}[title={Implementazione di un array}]
//si vuole inizializzare il seguente array di interi con una sequenza di 30
int voti[10];
int i;
for(i=0; i<10; i++){
voti[i]=30;
}
\end{lstlisting}

\section{Stringhe}
Gli array vengono utilizzati anche per memorizzare stringe, i metodi di implementazione di qusto tipo di dato ed i suoi utilizzi saranno specificati in seguito.
\section{Punatori e array}
Esiste uno stretto legame tra puntatori ed array poichè se dichiariamo un array a[n] la scrittura a[i] e quivale a *(a+i), questo significa che l'identificatore a in realtà è un puntatore alla prima della sequenza di n celle dell'array. Si osservi il seguente esempio:
\begin{lstlisting}[title={Utilizzo di puntatori come array}]
int vett[5];
int *p;
//le due righe seguenti sono equivalenti
p=&vett[0]; 
p=vett;
//per modificare la cella vett[2] si puo' agire cosi'
*(p+2)=7;    // == vett[2]=7
//quindi queste due scritture sono equivalenti
*(p+i) == vett[i]    //TRUE
//array dato in pasto ad una funzione
funz_random(vett) == funz_random(&vett[0])    //TRUE
//due dichiarazioni di funzione equivalenti
funzione_2(int v[]) == funzione_2(int *v)    //TRUE
\end{lstlisting}
Nelle ultime due righe abbiamo visto come vengono passati gli array alle funzioni, ovvero come indirizzo del loro primo elemento.\\
Tuttavia va ricordato che puntatori e vettori hanno caratteristiche molto diverse pichè i primi sono variabili mentre i secondi no e quindi non possono essere sottoposti alle stesse operazioni (in particolare assegnamento ed incremento) come si può osservare in seguito:
\begin{lstlisting}[title={Differenze puntatori/array}]
int vett[5];
int *p;
//operazioni valide
p=vett;
p++;
//operazioni NON valide
vett=p;
vett++;
\end{lstlisting}
 
\section{Nota teorica}
Osservando da vicino questa struttura si nota che la principale limitazione sta nel fatto che la dimensione di un array non può cambiare durante l'esecuzione del programma; questo implica che nel caso non si conoscano a tempo di programmazione le dimensioni di un input da memorizzare si dovrà necessariamente sovrastimare le dimensioni dell'array per evitare il rischio di \textbf{overflow}, con conseguente spreco memoria.\\ 
Tale complicazione è dovuta alla complessità di realizzazione del compilatore di un linguaggio: per farla breve se la macchina astratta (di un determinato linguaggio) conosce la quantità di memoria necessaria per un programma prima della sua esecuzione 
potrà operare in maniera molto più efficiente riservando subito tutta la memoria che le sarà necessaria, evitando così di dover cercare memoria libera mentre fa girare il programma; per questo motivo nella maggior parte dei linguaggi più comuni la possibilità di allocare memoria a tempo di esecuzione è permessa solo in casi speciali (in C tutti i casi in cui si utilizza \textbf{malloc} per l'allocazione dinamica della mamoria).\\



